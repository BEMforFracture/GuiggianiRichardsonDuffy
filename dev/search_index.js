var documenterSearchIndex = {"docs":
[{"location":"guide.html#Guide-d’utilisation","page":"Guide","title":"Guide d’utilisation","text":"","category":"section"},{"location":"guide.html#Choix-de-la-méthode-d’expansion-des-coefficients-de-Laurent","page":"Guide","title":"Choix de la méthode d’expansion des coefficients de Laurent","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":":analytical (si disponible): plus rapide et précis.\n:auto_diff: nécessite un noyau translation-invariant, calcule via AD.\n:semi_richardson: F₋₂ analytique, F₋₁ par Richardson.\n:full_richardson: générique, pas d’hypothèse forte.","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Exemple :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"I = guiggiani_singular_integral(\n    GuiggianiRichardsonDuffy.SplitLaplaceHypersingular,\n    ξ -> 1.0,\n    SVector(0.2, 0.3),\n    Inti.LagrangeSquare((SVector(0.0,0.0,0.0), SVector(1.0,0.0,0.0),\n                          SVector(0.0,1.0,0.0), SVector(1.0,1.0,0.0))),\n    16, 32;\n    expansion = :full_richardson,\n    first_contract = 1e-2, contract = 0.5,\n)","category":"page"},{"location":"guide.html#Réglages-de-quadrature","page":"Guide","title":"Réglages de quadrature","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"n_rho, n_theta contrôlent la précision angulaire/radiale.\nDes valeurs typiques: 8–32 selon la régularité de û et la courbure locale.","category":"page"},{"location":"guide.html#Paramètres-des-noyaux-élastostatiques","page":"Guide","title":"Paramètres des noyaux élastostatiques","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Passer λ, μ via les mots-clés :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"K = GuiggianiRichardsonDuffy.SplitElastostaticHypersingular\nI = guiggiani_singular_integral(K, ξ->1.0, SVector(0.3,0.4), el, 16, 32; expansion=:analytical, λ=1.0, μ=0.5)","category":"page"},{"location":"guide.html#Aide","page":"Guide","title":"Aide","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Depuis le REPL, ?guiggiani_singular_integral pour la docstring détaillée.","category":"page"},{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html#Main-function","page":"API","title":"Main function","text":"","category":"section"},{"location":"api.html#GuiggianiRichardsonDuffy.guiggiani_singular_integral","page":"API","title":"GuiggianiRichardsonDuffy.guiggiani_singular_integral","text":"guiggiani_singular_integral(\n\tK,\n\tû,\n\tx̂,\n\tel::Inti.ReferenceInterpolant,\n\tn_rho,\n\tn_theta;\n\tsorder::Val{P} = Val(-2),\n\texpansion::Symbol = :full_richardson,\n\tkernel_kwargs::NamedTuple = NamedTuple(),\n\trichardson_kwargs::NamedTuple = NamedTuple(),\n\tkwargs...,\n) where {P}\n\nGiven a kernel K, a function û defined on the reference element el, a point x̂ on the reference element where the singularity is located, the number of quadrature points in the radial direction n_rho, the number of quadrature points in the angular direction n_theta, and the order of the singularity sorder (which has to be -1, -2 or -3), computes the integral of the kernel over the reference element using the Guiggiani method using expansion of Laurent coefficients specified in the expansion argument.\n\nSee GuiggianiRichardsonDuffy.laurents_coeffs for the available expansion methods and their parameters.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Expansion-of-Laurent-coefficients","page":"API","title":"Expansion of Laurent coefficients","text":"","category":"section"},{"location":"api.html#GuiggianiRichardsonDuffy.laurents_coeffs","page":"API","title":"GuiggianiRichardsonDuffy.laurents_coeffs","text":"laurents_coeffs(K, el::Inti.ReferenceInterpolant, û, x̂; expansion = (method = :full_richardson,), kwargs...)\n\nGiven a kernel K, a reference element el, a function û defined on the reference element, and a point x̂ on the reference element, returns the laurent coefficients F₋₂ and F₋₁ for the kernel K in polar coordinates centered at x̂. The coefficients are computed using the method specified in the expansion argument, which can be one of the following:\n\n:analytical: uses analytical expressions for the coefficients (if available). kernel_kwargs... are passed to analytical functions.\n:auto_diff: uses semi-analytical expressions for the coefficients (if available i.e. when the property of the kernel being translation-invariant holds) based on automatic differentiation used in the ForwardDiff.jl package. kernel_kwargs... are passed to the kernel K̂.\n:semi_richardson: uses another semi-analytical method for the coefficients (if available i.e. when the property of the kernel being translation-invariant holds). richardson_kwargs... are passed to Richardson.extrapolate (see Richardson.jl) and kernel_kwargs... are passed to the kernel K̂.\n:full_richardson: uses Richardson extrapolation to compute both coefficients, available by default for any kernel. richardson_kwargs... are passed to Richardson.extrapolate (see Richardson.jl) and kernel_kwargs... are passed to the kernel K̂.\n\nK has to be called as K(qx, qy, r̂; kernelkwargs...) where r̂ is the normalized relative position vector, qx = (coords = x, normal = nx) and qy = (coords = y, normal = ny). K(qx, qy, r̂; kernelkwargs...) is returning the tuple (1/rˢ, K̂(qx, qy, r̂; kernel_kwargs...)) where s is the order of the singularity.\n\nYou can also put all the keyword arguments in kwargs..., they will be automatically split between kernel and richardson extrapolation arguments, which are in general : first_contract, contract, breaktol, maxeval, atol, rtol, x0, described in the Richardson.extrapolate documentation (see Richardson.jl).\n\n\n\n\n\n","category":"function"},{"location":"index.html#GuiggianiRichardsonDuffy.jl","page":"Accueil","title":"GuiggianiRichardsonDuffy.jl","text":"","category":"section"},{"location":"index.html","page":"Accueil","title":"Accueil","text":"TODO : resume ","category":"page"},{"location":"index.html#Install","page":"Accueil","title":"Install","text":"","category":"section"},{"location":"index.html#Quickstart","page":"Accueil","title":"Quickstart","text":"","category":"section"},{"location":"index.html","page":"Accueil","title":"Accueil","text":"using Inti, StaticArrays\nusing GuiggianiRichardsonDuffy\n\nel = Inti.LagrangeSquare((SVector(0.0,0.0,0.0), SVector(1.0,0.0,0.0),\n                          SVector(0.0,1.0,0.0), SVector(1.0,1.0,0.0)))\nx̂ = SVector(0.3, 0.4)\nK = GuiggianiRichardsonDuffy.SplitLaplaceHypersingular\nû(ξ) = 1.0\n\nI = guiggiani_singular_integral(K, û, x̂, el, 16, 32; expansion = :full_richardson)","category":"page"},{"location":"index.html","page":"Accueil","title":"Accueil","text":"See the complete Guide for variants and parameters.\nThe complete API documentation is available in the API section.\nDocstrings are available in the Docstrings section.","category":"page"},{"location":"docstrings.html#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.ANALYTICAL_KERNELS","page":"Docstrings","title":"GuiggianiRichardsonDuffy.ANALYTICAL_KERNELS","text":"const ANALYTICAL_KERNELS = [:LaplaceHypersingular, :ElastostaticHypersingular]\n\nAvailable kernels with analytical Laurent coefficients.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.EXPANSION_METHODS","page":"Docstrings","title":"GuiggianiRichardsonDuffy.EXPANSION_METHODS","text":"const EXPANSION_METHODS = [:analytical, :auto_diff, :semi_richardson, :full_richardson]\n\nAvailable expansion methods for Laurent coefficients of singular kernels.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.ElastostaticHypersingularClosedFormF₋₁-Tuple","page":"Docstrings","title":"GuiggianiRichardsonDuffy.ElastostaticHypersingularClosedFormF₋₁","text":"ElastostaticHypersingularClosedFormF₋₁(args...; kwargs...)\n\nCompute only F₋₁ the old way (analytically with F₋₂) such that F(ρ, θ) := ρ × J × Nᵖ × Vᵢₖⱼ = F₋₁ / ρ + F₋₂ / ρ² + O(1), for the elastostatic hypersingular kernel.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.ElastostaticHypersingularClosedFormF₋₂-Tuple","page":"Docstrings","title":"GuiggianiRichardsonDuffy.ElastostaticHypersingularClosedFormF₋₂","text":"ElastostaticHypersingularClosedFormF₋₂(args...; kwargs...)\n\nCompute only F₋₂ the old way (analytically with F₋₁) such that F(ρ, θ) := ρ × J × Nᵖ × Vᵢₖⱼ = F₋₁ / ρ + F₋₂ / ρ² + O(1), for the elastostatic hypersingular kernel.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.LaplaceHypersingularClosedFormF₋₁-Tuple","page":"Docstrings","title":"GuiggianiRichardsonDuffy.LaplaceHypersingularClosedFormF₋₁","text":"LaplaceHypersingularClosedFormF₋₁(args...; kwargs...)\n\nCompute only F₋₁ the old way (analytically with F₋₂) such that F(ρ, θ) := ρ × J × Nᵖ × Vᵢ = F₋₁ / ρ + F₋₂ / ρ² + O(1), for Laplace hypersingular kernel.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.LaplaceHypersingularClosedFormF₋₂-Tuple","page":"Docstrings","title":"GuiggianiRichardsonDuffy.LaplaceHypersingularClosedFormF₋₂","text":"LaplaceHypersingularClosedFormF₋₂(args...; kwargs...)\n\nCompute only F₋₂ the old way (analytically with F₋₁) such that F(ρ, θ) := ρ × J × Nᵖ × Vᵢ = F₋₁ / ρ + F₋₂ / ρ² + O(1), for Laplace hypersingular kernel.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.guiggiani_singular_integral-Union{Tuple{P}, Tuple{Any, Any, Any, Inti.ReferenceInterpolant, Any, Any}} where P","page":"Docstrings","title":"GuiggianiRichardsonDuffy.guiggiani_singular_integral","text":"guiggiani_singular_integral(\n\tK,\n\tû,\n\tx̂,\n\tel::Inti.ReferenceInterpolant,\n\tn_rho,\n\tn_theta;\n\tsorder::Val{P} = Val(-2),\n\texpansion::Symbol = :full_richardson,\n\tkernel_kwargs::NamedTuple = NamedTuple(),\n\trichardson_kwargs::NamedTuple = NamedTuple(),\n\tkwargs...,\n) where {P}\n\nGiven a kernel K, a function û defined on the reference element el, a point x̂ on the reference element where the singularity is located, the number of quadrature points in the radial direction n_rho, the number of quadrature points in the angular direction n_theta, and the order of the singularity sorder (which has to be -1, -2 or -3), computes the integral of the kernel over the reference element using the Guiggiani method using expansion of Laurent coefficients specified in the expansion argument.\n\nSee GuiggianiRichardsonDuffy.laurents_coeffs for the available expansion methods and their parameters.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.laurents_coeffs-Tuple{Any, Inti.ReferenceInterpolant, Any, Any}","page":"Docstrings","title":"GuiggianiRichardsonDuffy.laurents_coeffs","text":"laurents_coeffs(K, el::Inti.ReferenceInterpolant, û, x̂; expansion = (method = :full_richardson,), kwargs...)\n\nGiven a kernel K, a reference element el, a function û defined on the reference element, and a point x̂ on the reference element, returns the laurent coefficients F₋₂ and F₋₁ for the kernel K in polar coordinates centered at x̂. The coefficients are computed using the method specified in the expansion argument, which can be one of the following:\n\n:analytical: uses analytical expressions for the coefficients (if available). kernel_kwargs... are passed to analytical functions.\n:auto_diff: uses semi-analytical expressions for the coefficients (if available i.e. when the property of the kernel being translation-invariant holds) based on automatic differentiation used in the ForwardDiff.jl package. kernel_kwargs... are passed to the kernel K̂.\n:semi_richardson: uses another semi-analytical method for the coefficients (if available i.e. when the property of the kernel being translation-invariant holds). richardson_kwargs... are passed to Richardson.extrapolate (see Richardson.jl) and kernel_kwargs... are passed to the kernel K̂.\n:full_richardson: uses Richardson extrapolation to compute both coefficients, available by default for any kernel. richardson_kwargs... are passed to Richardson.extrapolate (see Richardson.jl) and kernel_kwargs... are passed to the kernel K̂.\n\nK has to be called as K(qx, qy, r̂; kernelkwargs...) where r̂ is the normalized relative position vector, qx = (coords = x, normal = nx) and qy = (coords = y, normal = ny). K(qx, qy, r̂; kernelkwargs...) is returning the tuple (1/rˢ, K̂(qx, qy, r̂; kernel_kwargs...)) where s is the order of the singularity.\n\nYou can also put all the keyword arguments in kwargs..., they will be automatically split between kernel and richardson extrapolation arguments, which are in general : first_contract, contract, breaktol, maxeval, atol, rtol, x0, described in the Richardson.extrapolate documentation (see Richardson.jl).\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.polar_kernel_fun-Tuple{Any, Inti.ReferenceInterpolant, Any, Any}","page":"Docstrings","title":"GuiggianiRichardsonDuffy.polar_kernel_fun","text":"polar_kernel_fun(K::Inti.AbstractKernel, el::Inti.ReferenceInterpolant, û, x̂)\n\nGiven a kernel K, a reference element el, a function û defined on the reference element, and a point x̂ on the reference element, returns a function F that computes the complete kernel in polar coordinates centered at x̂ : F(ρ, θ) = K(x, y) * J(ŷ) * ρ * û(ŷ) where x = el(x̂), ŷ = x̂ + ρ * (cos(θ), sin(θ)), y = el(ŷ), and J(ŷ) is the integration measure at ŷ. F will be called as F(ρ, θ). K has to be called as K(qx, qy) where qx = (coords = x, normal = nx) and qy = (coords = y, normal = ny) are cartesian points with their normals. \n\nK must return a unique value.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.rho_fun-Tuple{Any, Any}","page":"Docstrings","title":"GuiggianiRichardsonDuffy.rho_fun","text":"rho_fun(ref_domain::Inti.ReferenceDomain, x̂)\n\nGiven a reference domain ref_domain and a point x̂ in the reference domain, returns the function ρ(θ) that gives the distance from x̂ to the boundary of the reference domain in the direction θ. ρ will be called as ρ(θ).\n\n\n\n\n\n","category":"method"}]
}
