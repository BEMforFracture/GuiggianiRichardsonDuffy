var documenterSearchIndex = {"docs":
[{"location":"appendix.html#Appendix","page":"Appendix","title":"Appendix","text":"","category":"section"},{"location":"appendix.html#Analytical-formulas","page":"Appendix","title":"Analytical formulas","text":"","category":"section"},{"location":"appendix.html#Laplace-scalar-hypersingular-kernel","page":"Appendix","title":"Laplace scalar hypersingular kernel","text":"","category":"section"},{"location":"appendix.html","page":"Appendix","title":"Appendix","text":"F_-2(theta) = mathcal V(mathbf A(theta)) N^a(bm eta) mathbf J(bm eta)=frac-14pi A(theta)^3J_i(hatmathbf y)n_i(bmeta)","category":"page"},{"location":"appendix.html","page":"Appendix","title":"Appendix","text":"With A(theta) = mathbf A(theta) et hatmathbf A(theta) = mathbf A(theta)A(theta).","category":"page"},{"location":"appendix.html","page":"Appendix","title":"Appendix","text":"F_-1(theta) = frac3J(bmeta)4pi A(theta)^5A_m(theta)B_m(theta)N^a(bmeta) - fracJ(bmeta)4pi A(theta)^3c_alpha(theta)partial_alphaN^a(bmeta) -\nfrac14pi A(theta)^3c_alpha(theta)partial_alphaJ(bmeta)N^a(bmeta)","category":"page"},{"location":"appendix.html#Elastostatics-hypersingular-integral","page":"Appendix","title":"Elastostatics hypersingular integral","text":"","category":"section"},{"location":"appendix.html","page":"Appendix","title":"Appendix","text":"We let :","category":"page"},{"location":"appendix.html","page":"Appendix","title":"Appendix","text":"bmmathcal V_ijkell(mathbf r) = frac2muLambdar^3left3left(1-2nu)hat r_in_k+3nuhat r_kn_irighthatmathbf rcdot mathbf n^yright+3leftnudelta_ik - 5hat r_ihat r_kright(hatmathbf rcdotmathbf n^x)(hatmathbf rcdotmathbf n^y)+3left(1-2nu)hat r_kn^y_i+nuhat r_in^y_krighthatmathbf rcdotmathbf n^x+(mathbf n^ycdotmathbf n^x)left3nuhat r_ihat r_k+(1-2nu)delta_ikright + (4nu-1)n^y_in^x_k + (1-2nu)n^y_kn^x_i","category":"page"},{"location":"appendix.html","page":"Appendix","title":"Appendix","text":"So that the elastostatics hypersingular kernel can be written as :","category":"page"},{"location":"appendix.html","page":"Appendix","title":"Appendix","text":"V_ik(mathbf y mathbf x) = bmmathcal V_ijkell(mathbf r)n_j(bm x)n_ell(bm y) quad mathbf r = mathbf y - mathbf x","category":"page"},{"location":"appendix.html","page":"Appendix","title":"Appendix","text":"Where V_ik is the tensor kernel resulting from applying twice the elastic traction operator to the Kelvin fundamental solution ","category":"page"},{"location":"appendix.html","page":"Appendix","title":"Appendix","text":"V_ik(mathbf y mathbf x) = -C_ijabpartial_b C_kell cdpartial_d U_ac(mathbf r) quad U_ik(mathbf r) = fracLambda2mu rlefthat r_ihat r_k + (3-4nu)delta_ikright","category":"page"},{"location":"appendix.html","page":"Appendix","title":"Appendix","text":"Then, we have the following analytical formulas for the coefficients of the Laurent's expansion of F(rho theta) :","category":"page"},{"location":"appendix.html","page":"Appendix","title":"Appendix","text":"F_-2(theta) = bmmathcal V_ijkell(mathbf A(theta))J_ell(bm eta)n_j(bmeta)N^a(bm eta)","category":"page"},{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html#Main-function","page":"API","title":"Main function","text":"","category":"section"},{"location":"api.html#GuiggianiRichardsonDuffy.guiggiani_singular_integral","page":"API","title":"GuiggianiRichardsonDuffy.guiggiani_singular_integral","text":"guiggiani_singular_integral(\n\tK::Inti.AbstractKernel,\n\tû,\n\tx̂,\n\tel::Inti.ReferenceInterpolant,\n\tquad_rho,\n\tquad_theta,\n\tmethod::AbstractMethod = FullRichardsonExpansion(),\n)\n\nCompute the singular integral of kernel K over element el using Guiggiani's method.\n\nThis function evaluates:\n\n∫_{el} K(x, y) * û(ŷ) dS(y)\n\nwhere x = el(x̂) is the singular point on the element.\n\nThe method works by:\n\nTransforming to polar coordinates centered at x̂\nComputing Laurent coefficients (f₋₂, f₋₁) to extract the singularity\nIntegrating the regularized integrand: K - f₋₂/ρ² - f₋₁/ρ\nAdding back the analytical integrals of the singular terms\n\nArguments\n\nK::Inti.AbstractKernel: The kernel (must have a defined singularity_order)\nû: Density function defined on the reference element\nx̂: Singular point location on the reference element\nel::Inti.ReferenceInterpolant: The reference element\nquad_rho: Quadrature rule for the radial direction (e.g., Inti.GaussLegendre(10))\nquad_theta: Quadrature rule for the angular direction (e.g., Inti.GaussLegendre(20))\nmethod::AbstractMethod: Method for computing Laurent coefficients (see laurents_coeffs)\n\nReturns\n\nThe value of the singular integral\n\nNotes\n\nThe singularity order is automatically detected from Inti.singularity_order(K)\nIn polar coordinates, the order is adjusted by +1 (due to the Jacobian factor ρ)\nCurrently supports singularity orders -1, -2, and -3 in Cartesian coordinates\n\nExamples\n\n# Basic usage with default parameters\nK = Inti.Laplace(dim=2) |> Inti.HyperSingularKernel()\nel = # ... reference element ...\nû = ŷ -> 1.0  # constant density\nx̂ = SVector(0.5, 0.5)\nquad_rho = Inti.GaussLegendre(10)\nquad_theta = Inti.GaussLegendre(20)\n\nI = guiggiani_singular_integral(K, û, x̂, el, quad_rho, quad_theta)\n\n# Using automatic differentiation for speed\nI = guiggiani_singular_integral(K, û, x̂, el, quad_rho, quad_theta, AutoDiffExpansion())\n\n# With custom Richardson parameters\nparams = RichardsonParams(atol=1e-12, maxeval=10)\nI = guiggiani_singular_integral(K, û, x̂, el, quad_rho, quad_theta, FullRichardsonExpansion(params))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Expansion-of-Laurent-coefficients","page":"API","title":"Expansion of Laurent coefficients","text":"","category":"section"},{"location":"api.html#GuiggianiRichardsonDuffy.laurents_coeffs","page":"API","title":"GuiggianiRichardsonDuffy.laurents_coeffs","text":"laurents_coeffs(\n\tK::Inti.AbstractKernel, \n\tel::Inti.ReferenceInterpolant, \n\tû, \n\tx̂,\n\tmethod::AbstractMethod = FullRichardsonExpansion(),\n)\n\nCompute Laurent coefficients (f₋₂, f₋₁) for the kernel K in polar coordinates centered at x̂.\n\nArguments\n\nK::Inti.AbstractKernel: The kernel to expand\nel::Inti.ReferenceInterpolant: The reference element\nû: Function defined on the reference element (density function)\nx̂: Point on the reference element (singularity location)\nmethod::AbstractMethod: Expansion method to use. Can be:\nAnalyticalExpansion(): Uses closed-form analytical expressions (fastest, limited availability)\nAutoDiffExpansion(): Uses automatic differentiation (fast, requires translation-invariant kernels)\nSemiRichardsonExpansion(params): Hybrid Richardson extrapolation (moderate speed)\nFullRichardsonExpansion(params): Full Richardson extrapolation (slowest, always available)\n\nReturns\n\nℒ(θ): A memoized function that returns (f₋₂, f₋₁) for a given angle θ\n\nExamples\n\n# Using default method (FullRichardson)\nℒ = laurents_coeffs(K, el, û, x̂)\nf₋₂, f₋₁ = ℒ(0.5)  # Evaluate at θ = 0.5\n\n# Using AutoDiff method\nℒ = laurents_coeffs(K, el, û, x̂, AutoDiffExpansion())\n\n# Using explicit method with custom parameters\nparams = RichardsonParams(atol=1e-10, rtol=1e-8, maxeval=10)\nℒ = laurents_coeffs(K, el, û, x̂, FullRichardsonExpansion(params))\n\n\n\n\n\n","category":"function"},{"location":"guide.html#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide.html#Laurent's-expansions-methods","page":"Guide","title":"Laurent's expansions methods","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"The idea is to transform the original integral into a polar integral whose singularity is easier to handle. The elementary integral is written as a finite part integral :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"textfpint_tau_eK(mathbf y mathbf x)varphi(mathbf x) dS_y=textfpint_Delta_eK(bm eta bm xi)varphi(bm xi) J(bm xi) dxi","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Which is then transformed into a polar integral around the singularity point via the change of variables :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"hatmathbf x=bm eta+ rho mathbfc(theta) quad mathbf c(theta) = beginpmatrixcos theta  sin theta endpmatrix","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"So that the integral can be reduced, after rearranging terms (see [1]):","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"int_0^2pi int_0^hatrho(theta)leftF(rho theta) - fracF_-2(theta)rho^2 - fracF_-1(theta)rhorightmathrm drho dtheta + int_0^2pileftF_-1(theta)loghatrho(theta) - fracF_-2(theta)hatrho(theta)mathrm dthetaright","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Where F(rho theta) = K(bm eta(rho theta) bm xi(rho theta))N^a(bm xi(rho theta)) J(bm xi(rho theta)) rho ; N^a is the a-th shape function associated to the a-th node of the element, and F_-1(theta), F_-2(theta) are the coefficients of the Laurent's expansion of F(rho theta) around rho = 0, such that :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F(rho theta) = fracF_-2(theta)rho^2 + fracF_-1(theta)rho + mathcal O(1)","category":"page"},{"location":"guide.html#Expansion-using-analytical-formula","page":"Guide","title":"Expansion using analytical formula","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"If the kernel is known analytically, there is not fundamental difficulty in deriving the coefficients F_-1(theta) and F_-2(theta) analytically. This is the approach taken in the original paper by Guiggiani et al. [1] for the Laplace kernel ; we recall it in the next section for the hypersingular integral.","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"In the case translation invariant kernels, the F_-2(theta) coefficient (dominant term) can be easily derived from regular part of the kernel. Indeed, if the kernel can be written as :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"V(mathbf y mathbf x) = mathcal V(mathbf r)mathbf n(mathbf x) quad mathbf r = mathbf y - mathbf x","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Then, the dominant term of the Laurent's expansion of F(rho theta) is given by :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-2(theta) = mathcal V(mathbf A(theta)) N^a(bm eta) mathbf J(bm eta)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Where mathbf A(theta) = Dtau(bm eta) cdot mathbf c(theta), with Dtau the Jacobian matrix of the parametric mapping tau at the singularity point bm eta and mathbf J(bm eta) is the integration measure multiplied by the normal at point bm eta.","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Analytical formulas for the Laplace and elastostatics hypersingular kernels are given in the Appendix.","category":"page"},{"location":"guide.html#Expansion-using-automatic-differentiation","page":"Guide","title":"Expansion using automatic differentiation","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"If the kernel verifies the translation invariance property presented previously, it is possible to compute the coefficients of the Laurent's expansion using automatic differentiation. ","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"In fact, we let :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"mathcal F(rho theta) = rho^2F(rho theta)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"So that :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-2(theta) = mathcal F(0 theta) quad F_-1(theta) = fracpartial mathcal Fpartial rho(0 theta)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"The function mathcal F(rho theta) is mathematically regular but also numerically regular at rho = 0 since the singularity has been analytically removed by multiplying by rho^2. The analytical formula for mathcal F is given by :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"mathcal F(rho theta) = frac1mathbf A(rho theta)^3hat K(bm x(bmeta) bm x(bmxi(rho theta)))N^a(bm xi(rho theta)) J(bm xi(rho theta))","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Where hat K is the regular part of the kernel, i.e. K(bm y bm x) = frac1r^3hat K(bm y bm x), and ","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"bm A(rho theta) = Dtau(bmeta) cdot mathbf c(theta) + fracrho2mathbf c(theta)^TD^2bmtau(bmeta)mathbf c(theta)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"is such that mathbf r = rho mathbf A(rho theta) + mathcal O(rho^3).","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Here again, we retrieve the F_-2 coefficient easily by evaluating mathcal F at rho = 0. The F_-1 coefficient is obtained by computing the derivative of mathcal F with respect to rho at rho = 0 using automatic differentiation.","category":"page"},{"location":"guide.html#Expansion-using-a-mixed-approach-between-semi-analytical-formula-and-Richardson-extrapolation","page":"Guide","title":"Expansion using a mixed approach between semi-analytical formula and Richardson extrapolation","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"This approach is a hybrid between the previous ones and Richardson extrapolation. The dominant term F_-2(theta) is computed using the analytical formula, while the F_-1(theta) coefficient is computed using a numerical approximation based on Richardson extrapolation:","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-2(theta) = frac1mathbf A(0 theta)^3hat K(bm x(bmeta) bm x(bmeta))N^a(bmeta) J(bmeta)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-1(theta) = fracmathrm dmathcal F(rho theta)mathrm drhobigg_rho = 0=rho^-1leftmathcal F(rho theta) - F_-2(theta)right + mathcal O(rho)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"In a strict sense, this approximation of evaluating rho^-1leftmathcal F(rho theta) - F_-2(theta)right for a small value of rho is indeed a first approximation, but of first order.","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"We can improve the accuracy of this approximation by doing as follows:","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"(a)quad rho^-1leftmathcal F(rho theta) - F_-2(theta)right = F_-1(theta) + rho F_0(theta) + mathcal O(rho^2)\n(b)quad (trho)^-1leftmathcal F(trho theta) - F_-2(theta)right = F_-1(theta) + trho F_0(theta) + mathcal O(rho^2)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"By taking the combination (b) - t times (a), we can eliminate the O(rho) term and obtain a second-order accurate approximation of F_-1(theta):","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"(c)quad F_-1(theta) = frac11 - trho^-1leftt^-1mathcal F(trho theta) - tmathcal F(rho theta) + (t - t^-1)F_-2(theta)right + E_2","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Where E_2 = t(1 - t)rho^2 F_1(theta) + mathcal O(rho^3) is the truncation error. By repeating the previous procedure, e.g. by using (c) as is, then evaluating it with rho replaced by trho and taking a suitable weighted combination of the two approximations of F_-1(theta) yields a new approximation whose truncation error is O(rho^3), and so on.","category":"page"},{"location":"guide.html#Full-Richardson-expansion","page":"Guide","title":"Full Richardson expansion","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"This method consists in using the Richardson extrapolation procedure to compute both coefficients F_-2(theta) and F_-1(theta):","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-2(theta) = lim_rho to 0rho^2 F(rho theta)\nF_-1(theta) = lim_rho to 0leftrho F(rho theta) - fracF_-2(theta)rhoright","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"These are the mathematical definitions of the coefficients, but sometimes, the function mathcal F(rho theta) = rho^2 F(rho theta) cannot be obtained analytically with a stable formula. This Full Richardson extrapolation method is then performed numerically by evaluating F(rho theta) for a sequence of decreasing values of rho and applying the Richardson extrapolation procedure to compute the limits above ; this is the default method if we don't known any particular property of the kernel.","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"We have to be aware of the fact that the evaluation of F(rho theta) for very small values of rho can be numerically unstable if the point are too small, after a certain number of Richardson iterations.","category":"page"},{"location":"references.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"references.html","page":"References","title":"References","text":"M. Guiggiani, G. Krishnasamy, T. J. Rudolphi and F. J. Rizzo. A General Algorithm for the Numerical Solution of Hypersingular Boundary Integral Equations. Journal of Applied Mechanics 59, 604–614 (1992). Accessed on Oct 18, 2024.\n\n\n\n","category":"page"},{"location":"index.html#GuiggianiRichardsonDuffy.jl","page":"Welcome","title":"GuiggianiRichardsonDuffy.jl","text":"","category":"section"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"A Julia package for the numerical computation of laurent's coefficients expansion of singular kernels, and the evaluation of the associated singular integrals over boundary elements, which consist of computing the Cauchy principal value or Hadamard finite part over parametric elements.","category":"page"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"The idea of this package was originally proposed by Guiggiani in 1992 [1].","category":"page"},{"location":"index.html#Install","page":"Welcome","title":"Install","text":"","category":"section"},{"location":"index.html#Quickstart","page":"Welcome","title":"Quickstart","text":"","category":"section"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"using Inti, StaticArrays\nusing GuiggianiRichardsonDuffy\n\nel = Inti.LagrangeSquare((SVector(0.0,0.0,0.0), SVector(1.0,0.0,0.0),\n                          SVector(0.0,1.0,0.0), SVector(1.0,1.0,0.0)))\nx̂ = SVector(0.3, 0.4)\nK = GuiggianiRichardsonDuffy.SplitLaplaceHypersingular\nû(ξ) = 1.0\n\nI = guiggiani_singular_integral(K, û, x̂, el, 16, 32; expansion = :full_richardson)","category":"page"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"See the complete Guide for variants and parameters.\nThe complete API documentation is available in the API section.\nDocstrings are available in the Docstrings section.","category":"page"},{"location":"docstrings.html#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.ANALYTICAL_EXPANSIONS","page":"Docstrings","title":"GuiggianiRichardsonDuffy.ANALYTICAL_EXPANSIONS","text":"const ANALYTICAL_EXPANSIONS = [:LaplaceHypersingular, :ElastostaticHypersingular]\n\nAvailable kernels with analytical Laurent coefficients.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.guiggiani_singular_integral","page":"Docstrings","title":"GuiggianiRichardsonDuffy.guiggiani_singular_integral","text":"guiggiani_singular_integral(\n\tK::Inti.AbstractKernel,\n\tû,\n\tx̂,\n\tel::Inti.ReferenceInterpolant,\n\tquad_rho,\n\tquad_theta,\n\tmethod::AbstractMethod = FullRichardsonExpansion(),\n)\n\nCompute the singular integral of kernel K over element el using Guiggiani's method.\n\nThis function evaluates:\n\n∫_{el} K(x, y) * û(ŷ) dS(y)\n\nwhere x = el(x̂) is the singular point on the element.\n\nThe method works by:\n\nTransforming to polar coordinates centered at x̂\nComputing Laurent coefficients (f₋₂, f₋₁) to extract the singularity\nIntegrating the regularized integrand: K - f₋₂/ρ² - f₋₁/ρ\nAdding back the analytical integrals of the singular terms\n\nArguments\n\nK::Inti.AbstractKernel: The kernel (must have a defined singularity_order)\nû: Density function defined on the reference element\nx̂: Singular point location on the reference element\nel::Inti.ReferenceInterpolant: The reference element\nquad_rho: Quadrature rule for the radial direction (e.g., Inti.GaussLegendre(10))\nquad_theta: Quadrature rule for the angular direction (e.g., Inti.GaussLegendre(20))\nmethod::AbstractMethod: Method for computing Laurent coefficients (see laurents_coeffs)\n\nReturns\n\nThe value of the singular integral\n\nNotes\n\nThe singularity order is automatically detected from Inti.singularity_order(K)\nIn polar coordinates, the order is adjusted by +1 (due to the Jacobian factor ρ)\nCurrently supports singularity orders -1, -2, and -3 in Cartesian coordinates\n\nExamples\n\n# Basic usage with default parameters\nK = Inti.Laplace(dim=2) |> Inti.HyperSingularKernel()\nel = # ... reference element ...\nû = ŷ -> 1.0  # constant density\nx̂ = SVector(0.5, 0.5)\nquad_rho = Inti.GaussLegendre(10)\nquad_theta = Inti.GaussLegendre(20)\n\nI = guiggiani_singular_integral(K, û, x̂, el, quad_rho, quad_theta)\n\n# Using automatic differentiation for speed\nI = guiggiani_singular_integral(K, û, x̂, el, quad_rho, quad_theta, AutoDiffExpansion())\n\n# With custom Richardson parameters\nparams = RichardsonParams(atol=1e-12, maxeval=10)\nI = guiggiani_singular_integral(K, û, x̂, el, quad_rho, quad_theta, FullRichardsonExpansion(params))\n\n\n\n\n\n","category":"function"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.laurents_coeffs","page":"Docstrings","title":"GuiggianiRichardsonDuffy.laurents_coeffs","text":"laurents_coeffs(\n\tK::Inti.AbstractKernel, \n\tel::Inti.ReferenceInterpolant, \n\tû, \n\tx̂,\n\tmethod::AbstractMethod = FullRichardsonExpansion(),\n)\n\nCompute Laurent coefficients (f₋₂, f₋₁) for the kernel K in polar coordinates centered at x̂.\n\nArguments\n\nK::Inti.AbstractKernel: The kernel to expand\nel::Inti.ReferenceInterpolant: The reference element\nû: Function defined on the reference element (density function)\nx̂: Point on the reference element (singularity location)\nmethod::AbstractMethod: Expansion method to use. Can be:\nAnalyticalExpansion(): Uses closed-form analytical expressions (fastest, limited availability)\nAutoDiffExpansion(): Uses automatic differentiation (fast, requires translation-invariant kernels)\nSemiRichardsonExpansion(params): Hybrid Richardson extrapolation (moderate speed)\nFullRichardsonExpansion(params): Full Richardson extrapolation (slowest, always available)\n\nReturns\n\nℒ(θ): A memoized function that returns (f₋₂, f₋₁) for a given angle θ\n\nExamples\n\n# Using default method (FullRichardson)\nℒ = laurents_coeffs(K, el, û, x̂)\nf₋₂, f₋₁ = ℒ(0.5)  # Evaluate at θ = 0.5\n\n# Using AutoDiff method\nℒ = laurents_coeffs(K, el, û, x̂, AutoDiffExpansion())\n\n# Using explicit method with custom parameters\nparams = RichardsonParams(atol=1e-10, rtol=1e-8, maxeval=10)\nℒ = laurents_coeffs(K, el, û, x̂, FullRichardsonExpansion(params))\n\n\n\n\n\n","category":"function"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.polar_kernel_fun-Tuple{Any, Inti.ReferenceInterpolant, Any, Any}","page":"Docstrings","title":"GuiggianiRichardsonDuffy.polar_kernel_fun","text":"polar_kernel_fun(K, el::Inti.ReferenceInterpolant, û, x̂)\n\nGiven a kernel K, a reference element el, a function û defined on the reference element,  and a point x̂ on the reference element, returns a function F that computes the complete  kernel in polar coordinates centered at x̂:\n\nF(ρ, θ) = K(x, y) * J(ŷ) * ρ * û(ŷ)\n\nwhere:\n\nx = el(x̂) is the physical position of the source point\nŷ = x̂ + ρ * (cos(θ), sin(θ)) is the parametric position in polar coordinates\ny = el(ŷ) is the physical position\nJ(ŷ) is the integration measure at ŷ\n\nThe kernel K is called as K(qx, qy) where qx and qy are named tuples with fields  coords and normal.\n\nArguments\n\nK: The kernel function (or SplitKernel)\nel::Inti.ReferenceInterpolant: The reference element\nû: Function defined on the reference element\nx̂: Point on the reference element (singularity location)\n\nReturns\n\nF(ρ, θ): A function that evaluates the kernel in polar coordinates\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.rho_fun-Tuple{Any, Any}","page":"Docstrings","title":"GuiggianiRichardsonDuffy.rho_fun","text":"rho_fun(ref_domain::Inti.ReferenceDomain, x̂)\n\nGiven a reference domain ref_domain and a point x̂ in the reference domain, returns the  function ρ(θ) that gives the distance from x̂ to the boundary of the reference domain in  the direction θ.\n\nArguments\n\nref_domain::Inti.ReferenceDomain: The reference domain (e.g., ReferenceSquare(), ReferenceTriangle())\nx̂: Point in the reference domain\n\nReturns\n\nρ(θ): Function that computes the distance to the boundary at angle θ\n\n\n\n\n\n","category":"method"}]
}
