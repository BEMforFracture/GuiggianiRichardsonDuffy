var documenterSearchIndex = {"docs":
[{"location":"guide.html#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide.html#Laurent's-expansions-methods","page":"Guide","title":"Laurent's expansions methods","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"The idea is to transform the original integral into a polar integral whose singularity is easier to handle. The elementary integral is written as a finite part integral :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"textfpint_tau_eK(mathbf y mathbf x)varphi(mathbf x) dS_y=textfpint_Delta_eK(bm eta bm xi)varphi(bm xi) J(bm xi) dxi","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Which is then transformed into a polar integral around the singularity point via the change of variables :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"hatmathbf x=bm eta+ rho mathbfc(theta) quad mathbf c(theta) = beginpmatrixcos theta  sin theta endpmatrix","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"So that the integral can be reduced, after rearranging terms (see [1]):","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"int_0^2pi int_0^hatrho(theta)leftF(rho theta) - fracF_-2(theta)rho^2 - fracF_-1(theta)rhorightmathrm drho dtheta + int_0^2pileftF_-1(theta)loghatrho(theta) - fracF_-2(theta)hatrho(theta)mathrm dthetaright","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Where F(rho theta) = K(bm eta(rho theta) bm xi(rho theta))N^a(bm xi(rho theta)) J(bm xi(rho theta)) rho ; N^a is the a-th shape function associated to the a-th node of the element, and F_-1(theta), F_-2(theta) are the coefficients of the Laurent's expansion of F(rho theta) around rho = 0, such that :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F(rho theta) = fracF_-2(theta)rho^2 + fracF_-1(theta)rho + mathcal O(1)","category":"page"},{"location":"guide.html#Expansion-using-analytical-formula","page":"Guide","title":"Expansion using analytical formula","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"If the kernel is known analytically, there is not fundamental difficulty in deriving the coefficients F_-1(theta) and F_-2(theta) analytically. This is the approach taken in the original paper by Guiggiani et al. [1] for the Laplace kernel ; we recall it in the next section for the hypersingular integral.","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"In the case translation invariant kernels, the F_-2(theta) coefficient (dominant term) can be easily derived from regular part of the kernel. Indeed, if the kernel can be written as :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"V(mathbf y mathbf x) = mathcal V(mathbf r)mathbf n(mathbf x) quad mathbf r = mathbf y - mathbf x","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Then, the dominant term of the Laurent's expansion of F(rho theta) is given by :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-2(theta) = mathcal V(mathbf A(theta)) N^a(bm eta) mathbf J(bm eta)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Where mathbf A(theta) = Dtau(bm eta) cdot mathbf c(theta), with Dtau the Jacobian matrix of the parametric mapping tau at the singularity point bm eta and mathbf J(bm eta) is the integration measure multiplied by the normal at point bm eta.","category":"page"},{"location":"guide.html#Laplace-scalar-hypersingular-kernel","page":"Guide","title":"Laplace scalar hypersingular kernel","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-2(theta) = mathcal V(mathbf A(theta)) N^a(bm eta) mathbf J(bm eta)=frac-14pi A(theta)^3left(n_j(bmeta)J_j(hatmathbf y)n_j(bmeta)right)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"With A(theta) = mathbf A(theta) et hatmathbf A(theta) = fracmathbf A(theta)A(theta).","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-1(theta) = frac3J(bmeta)4pi A(theta)^5A_m(theta)B_m(theta)N^a(bmeta) - fracJ(bmeta)4pi A(theta)^3c_alpha(theta)partial_alphaN^a(bmeta) -\nfrac14pi A(theta)^3c_alpha(theta)partial_alphaJ(bmeta)N^a(bmeta)","category":"page"},{"location":"guide.html#Elastostatics-hypersingular-integral","page":"Guide","title":"Elastostatics hypersingular integral","text":"","category":"section"},{"location":"guide.html#Expansion-using-automatic-differentiation","page":"Guide","title":"Expansion using automatic differentiation","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"If the kernel verifies the translation invariance property presented previously, it is possible to compute the coefficients of the Laurent's expansion using automatic differentiation. ","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"In fact, we let :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"mathcal F(rho theta) = rho^2F(rho theta)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"So that :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-2(theta) = mathcal F(0 theta) quad F_-1(theta) = fracpartial mathcal Fpartial rho(0 theta)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"The function mathcal F(rho theta) is mathematically regular but also numerically regular at rho = 0 since the singularity has been analytically removed by multiplying by rho^2. The analytical formula for mathcal F is given by :","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"mathcal F(rho theta) = frac1mathbf A(rho theta)^3hat K(bm x(bmeta) bm x(bmxi(rho theta)))N^a(bm xi(rho theta)) J(bm xi(rho theta))","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Where hat K is the regular part of the kernel, i.e. K(bm y bm x) = frac1r^3hat K(bm y bm x), and ","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"bm A(rho theta) = Dtau(bmeta) cdot mathbf c(theta) + fracrho2mathbf c(theta)^TD^2bmtau(bmeta)mathbf c(theta)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"is such that mathbf r = rho mathbf A(rho theta) + mathcal O(rho^3).","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Here again, we retrieve the F_-2 coefficient easily by evaluating mathcal F at rho = 0. The F_-1 coefficient is obtained by computing the derivative of mathcal F with respect to rho at rho = 0 using automatic differentiation.","category":"page"},{"location":"guide.html#Expansion-using-a-mixed-approach-between-semi-analytical-formula-and-Richardson-extrapolation","page":"Guide","title":"Expansion using a mixed approach between semi-analytical formula and Richardson extrapolation","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"This approach is a hybrid between the previous ones and Richardson extrapolation. The dominant term F_-2(theta) is computed using the analytical formula, while the F_-1(theta) coefficient is computed using a numerical approximation based on Richardson extrapolation:","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-2(theta) = frac1mathbf A(0 theta)^3hat K(bm x(bmeta) bm x(bmeta))N^a(bmeta) J(bmeta)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-1(theta) = fracmathrm dmathcal F(rho theta)mathrm drhobigg_rho = 0=rho^-1leftmathcal F(rho theta) - F_-2(theta)right + mathcal O(rho)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"In a strict sense, this approximation of evaluating rho^-1leftmathcal F(rho theta) - F_-2(theta)right for a small value of rho is indeed a first approximation, but of first order.","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"We can improve the accuracy of this approximation by doing as follows:","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"(a)quad rho^-1leftmathcal F(rho theta) - F_-2(theta)right = F_-1(theta) + rho F_0(theta) + mathcal O(rho^2)\n(b)quad (trho)^-1leftmathcal F(trho theta) - F_-2(theta)right = F_-1(theta) + trho F_0(theta) + mathcal O(rho^2)","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"By taking the combination (b) - t times (a), we can eliminate the O(rho) term and obtain a second-order accurate approximation of F_-1(theta):","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"(c)quad F_-1(theta) = frac11 - trho^-1leftt^-1mathcal F(trho theta) - tmathcal F(rho theta) + (t - t^-1)F_-2(theta)right + E_2","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Where E_2 = t(1 - t)rho^2 F_1(theta) + mathcal O(rho^3) is the truncation error. By repeating the previous procedure, e.g. by using (c) as is, then evaluating it with rho replaced by trho and taking a suitable weighted combination of the two approximations of F_1(theta) yields a new approximation whose truncation error is O(rho^3), and so on.","category":"page"},{"location":"guide.html#Full-Richardson-expansion","page":"Guide","title":"Full Richardson expansion","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"This method consists in using the Richardson extrapolation procedure to compute both coefficients F_-2(theta) and F_-1(theta):","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"F_-2(theta) = lim_rho to 0rho^2 F(rho theta)\nF_-1(theta) = lim_rho to 0leftrho F(rho theta) - fracF_-2(theta)rhoright","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"These are the mathematical definitions of the coefficients, but sometimes, the function mathcal F(rho theta) = rho^2 F(rho theta) cannot be obtained analytically with a stable formula. This Full Richardson extrapolation method is then performed numerically by evaluating F(rho theta) for a sequence of decreasing values of rho and applying the Richardson extrapolation procedure to compute the limits above ; this is the default method if we don't known any particular property of the kernel.","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"We have to be aware of the fact that the evaluation of F(rho theta) for very small values of rho can be numerically unstable if the point are too small, after a certain number of Richardson iterations.","category":"page"},{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html#Main-function","page":"API","title":"Main function","text":"","category":"section"},{"location":"api.html#GuiggianiRichardsonDuffy.guiggiani_singular_integral","page":"API","title":"GuiggianiRichardsonDuffy.guiggiani_singular_integral","text":"guiggiani_singular_integral(\n\tK,\n\tû,\n\tx̂,\n\tel::Inti.ReferenceInterpolant,\n\tn_rho,\n\tn_theta;\n\tsorder::Val{P} = Val(-2),\n\texpansion::Symbol = :full_richardson,\n\tkernel_kwargs::NamedTuple = NamedTuple(),\n\trichardson_kwargs::NamedTuple = NamedTuple(),\n\tname::Symbol = :LaplaceHypersingular,\n\tkwargs...,\n) where {P}\n\nGiven a kernel K, a function û defined on the reference element el, a point x̂ on the reference element where the singularity is located, the number of quadrature points in the radial direction n_rho, the number of quadrature points in the angular direction n_theta, and the order of the singularity sorder (which has to be -1, -2 or -3), computes the integral of the kernel over the reference element using the Guiggiani method using expansion of Laurent coefficients specified in the expansion argument.\n\nSee GuiggianiRichardsonDuffy.laurents_coeffs for the available expansion methods and their parameters.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Expansion-of-Laurent-coefficients","page":"API","title":"Expansion of Laurent coefficients","text":"","category":"section"},{"location":"api.html#GuiggianiRichardsonDuffy.laurents_coeffs","page":"API","title":"GuiggianiRichardsonDuffy.laurents_coeffs","text":"laurents_coeffs(\n\tK, el::Inti.ReferenceInterpolant, û, x̂;\n\texpansion::Symbol = :full_richardson,\n\tkernel_kwargs::NamedTuple = NamedTuple(),\n\trichardson_kwargs::NamedTuple = NamedTuple(),\n\tname::Symbol = :LaplaceHypersingular,\n\tkwargs...,\n\t)\n\nGiven a kernel K, a reference element el, a function û defined on the reference element, and a point x̂ on the reference element, returns a function ℒ(θ) that computes the Laurent coefficients (f₋₂, f₋₁) for the kernel K in polar coordinates centered at x̂. The coefficients are computed using the method specified in the expansion argument, which can be one of the following:\n\n:analytical: uses analytical expressions for the coefficients (if available). kernel_kwargs... are passed to analytical functions.\n:auto_diff: uses semi-analytical expressions for the coefficients (if available i.e. when the property of the kernel being translation-invariant holds) based on automatic differentiation used in the ForwardDiff.jl package. kernel_kwargs... are passed to the kernel K̂.\n:semi_richardson: uses another semi-analytical method for the coefficients (if available i.e. when the property of the kernel being translation-invariant holds). richardson_kwargs... are passed to Richardson.extrapolate (see Richardson.jl) and kernel_kwargs... are passed to the kernel K̂.\n:full_richardson: uses Richardson extrapolation to compute both coefficients, available by default for any kernel. richardson_kwargs... are passed to Richardson.extrapolate (see Richardson.jl) and kernel_kwargs... are passed to the kernel K̂.\n\nK has to be called as K(qx, qy, r̂; kernelkwargs...) where r̂ is the normalized relative position vector, qx = (coords = x, normal = nx) and qy = (coords = y, normal = ny). K(qx, qy, r̂; kernelkwargs...) is returning the tuple (1/rˢ, K̂(qx, qy, r̂; kernel_kwargs...)) where s is the order of the singularity.\n\nYou can also put all the keyword arguments in kwargs..., they will be automatically split between kernel and richardson extrapolation arguments, which are in general : first_contract, contract, breaktol, maxeval, atol, rtol, x0, described in the Richardson.extrapolate documentation (see Richardson.jl).\n\nname : Name of the kernel, used only for analytical expansions. Available kernels are in ANALYTICAL_KERNELS.\n\nReturns\n\nℒ: A memoized function ℒ(θ) that returns (f₋₂, f₋₁) for a given angle θ.\n\nExample\n\nℒ = laurents_coeffs(K, el, û, x̂; expansion=:auto_diff)\nf₋₂, f₋₁ = ℒ(0.5)  # Evaluate at θ = 0.5\n\n\n\n\n\n","category":"function"},{"location":"references.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"references.html","page":"References","title":"References","text":"M. Guiggiani, G. Krishnasamy, T. J. Rudolphi and F. J. Rizzo. A General Algorithm for the Numerical Solution of Hypersingular Boundary Integral Equations. Journal of Applied Mechanics 59, 604–614 (1992). Accessed on Oct 18, 2024.\n\n\n\n","category":"page"},{"location":"index.html#GuiggianiRichardsonDuffy.jl","page":"Welcome","title":"GuiggianiRichardsonDuffy.jl","text":"","category":"section"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"A Julia package for the numerical computation of laurent's coefficients expansion of singular kernels, and the evaluation of the associated singular integrals over boundary elements, which consist of computing the Cauchy principal value or Hadamard finite part over parametric elements.","category":"page"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"The idea of this package was originally proposed by Guiggiani in 1992 [1].","category":"page"},{"location":"index.html#Install","page":"Welcome","title":"Install","text":"","category":"section"},{"location":"index.html#Quickstart","page":"Welcome","title":"Quickstart","text":"","category":"section"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"using Inti, StaticArrays\nusing GuiggianiRichardsonDuffy\n\nel = Inti.LagrangeSquare((SVector(0.0,0.0,0.0), SVector(1.0,0.0,0.0),\n                          SVector(0.0,1.0,0.0), SVector(1.0,1.0,0.0)))\nx̂ = SVector(0.3, 0.4)\nK = GuiggianiRichardsonDuffy.SplitLaplaceHypersingular\nû(ξ) = 1.0\n\nI = guiggiani_singular_integral(K, û, x̂, el, 16, 32; expansion = :full_richardson)","category":"page"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"See the complete Guide for variants and parameters.\nThe complete API documentation is available in the API section.\nDocstrings are available in the Docstrings section.","category":"page"},{"location":"docstrings.html#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.ANALYTICAL_KERNELS","page":"Docstrings","title":"GuiggianiRichardsonDuffy.ANALYTICAL_KERNELS","text":"const ANALYTICAL_KERNELS = [:LaplaceHypersingular, :ElastostaticHypersingular]\n\nAvailable kernels with analytical Laurent coefficients.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.EXPANSION_METHODS","page":"Docstrings","title":"GuiggianiRichardsonDuffy.EXPANSION_METHODS","text":"const EXPANSION_METHODS = [:analytical, :auto_diff, :semi_richardson, :full_richardson]\n\nAvailable expansion methods for Laurent coefficients of singular kernels.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.ElastostaticHypersingularClosedFormF₋₁-Tuple","page":"Docstrings","title":"GuiggianiRichardsonDuffy.ElastostaticHypersingularClosedFormF₋₁","text":"ElastostaticHypersingularClosedFormF₋₁(args...; kwargs...)\n\nCompute only F₋₁ the old way (analytically with F₋₂) such that F(ρ, θ) := ρ × J × Nᵖ × Vᵢₖⱼ = F₋₁ / ρ + F₋₂ / ρ² + O(1), for the elastostatic hypersingular kernel.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.ElastostaticHypersingularClosedFormF₋₂-Tuple","page":"Docstrings","title":"GuiggianiRichardsonDuffy.ElastostaticHypersingularClosedFormF₋₂","text":"ElastostaticHypersingularClosedFormF₋₂(args...; kwargs...)\n\nCompute only F₋₂ the old way (analytically with F₋₁) such that F(ρ, θ) := ρ × J × Nᵖ × Vᵢₖⱼ = F₋₁ / ρ + F₋₂ / ρ² + O(1), for the elastostatic hypersingular kernel.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.LaplaceHypersingularClosedFormF₋₁-Tuple","page":"Docstrings","title":"GuiggianiRichardsonDuffy.LaplaceHypersingularClosedFormF₋₁","text":"LaplaceHypersingularClosedFormF₋₁(args...; kwargs...)\n\nCompute only F₋₁ the old way (analytically with F₋₂) such that F(ρ, θ) := ρ × J × Nᵖ × Vᵢ = F₋₁ / ρ + F₋₂ / ρ² + O(1), for Laplace hypersingular kernel.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.LaplaceHypersingularClosedFormF₋₂-Tuple","page":"Docstrings","title":"GuiggianiRichardsonDuffy.LaplaceHypersingularClosedFormF₋₂","text":"LaplaceHypersingularClosedFormF₋₂(args...; kwargs...)\n\nCompute only F₋₂ the old way (analytically with F₋₁) such that F(ρ, θ) := ρ × J × Nᵖ × Vᵢ = F₋₁ / ρ + F₋₂ / ρ² + O(1), for Laplace hypersingular kernel.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.guiggiani_singular_integral-Union{Tuple{P}, Tuple{Any, Any, Any, Inti.ReferenceInterpolant, Any, Any}} where P","page":"Docstrings","title":"GuiggianiRichardsonDuffy.guiggiani_singular_integral","text":"guiggiani_singular_integral(\n\tK,\n\tû,\n\tx̂,\n\tel::Inti.ReferenceInterpolant,\n\tn_rho,\n\tn_theta;\n\tsorder::Val{P} = Val(-2),\n\texpansion::Symbol = :full_richardson,\n\tkernel_kwargs::NamedTuple = NamedTuple(),\n\trichardson_kwargs::NamedTuple = NamedTuple(),\n\tname::Symbol = :LaplaceHypersingular,\n\tkwargs...,\n) where {P}\n\nGiven a kernel K, a function û defined on the reference element el, a point x̂ on the reference element where the singularity is located, the number of quadrature points in the radial direction n_rho, the number of quadrature points in the angular direction n_theta, and the order of the singularity sorder (which has to be -1, -2 or -3), computes the integral of the kernel over the reference element using the Guiggiani method using expansion of Laurent coefficients specified in the expansion argument.\n\nSee GuiggianiRichardsonDuffy.laurents_coeffs for the available expansion methods and their parameters.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.laurents_coeffs-Tuple{Any, Inti.ReferenceInterpolant, Any, Any}","page":"Docstrings","title":"GuiggianiRichardsonDuffy.laurents_coeffs","text":"laurents_coeffs(\n\tK, el::Inti.ReferenceInterpolant, û, x̂;\n\texpansion::Symbol = :full_richardson,\n\tkernel_kwargs::NamedTuple = NamedTuple(),\n\trichardson_kwargs::NamedTuple = NamedTuple(),\n\tname::Symbol = :LaplaceHypersingular,\n\tkwargs...,\n\t)\n\nGiven a kernel K, a reference element el, a function û defined on the reference element, and a point x̂ on the reference element, returns a function ℒ(θ) that computes the Laurent coefficients (f₋₂, f₋₁) for the kernel K in polar coordinates centered at x̂. The coefficients are computed using the method specified in the expansion argument, which can be one of the following:\n\n:analytical: uses analytical expressions for the coefficients (if available). kernel_kwargs... are passed to analytical functions.\n:auto_diff: uses semi-analytical expressions for the coefficients (if available i.e. when the property of the kernel being translation-invariant holds) based on automatic differentiation used in the ForwardDiff.jl package. kernel_kwargs... are passed to the kernel K̂.\n:semi_richardson: uses another semi-analytical method for the coefficients (if available i.e. when the property of the kernel being translation-invariant holds). richardson_kwargs... are passed to Richardson.extrapolate (see Richardson.jl) and kernel_kwargs... are passed to the kernel K̂.\n:full_richardson: uses Richardson extrapolation to compute both coefficients, available by default for any kernel. richardson_kwargs... are passed to Richardson.extrapolate (see Richardson.jl) and kernel_kwargs... are passed to the kernel K̂.\n\nK has to be called as K(qx, qy, r̂; kernelkwargs...) where r̂ is the normalized relative position vector, qx = (coords = x, normal = nx) and qy = (coords = y, normal = ny). K(qx, qy, r̂; kernelkwargs...) is returning the tuple (1/rˢ, K̂(qx, qy, r̂; kernel_kwargs...)) where s is the order of the singularity.\n\nYou can also put all the keyword arguments in kwargs..., they will be automatically split between kernel and richardson extrapolation arguments, which are in general : first_contract, contract, breaktol, maxeval, atol, rtol, x0, described in the Richardson.extrapolate documentation (see Richardson.jl).\n\nname : Name of the kernel, used only for analytical expansions. Available kernels are in ANALYTICAL_KERNELS.\n\nReturns\n\nℒ: A memoized function ℒ(θ) that returns (f₋₂, f₋₁) for a given angle θ.\n\nExample\n\nℒ = laurents_coeffs(K, el, û, x̂; expansion=:auto_diff)\nf₋₂, f₋₁ = ℒ(0.5)  # Evaluate at θ = 0.5\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.polar_kernel_fun-Tuple{Any, Inti.ReferenceInterpolant, Any, Any}","page":"Docstrings","title":"GuiggianiRichardsonDuffy.polar_kernel_fun","text":"polar_kernel_fun(K::Inti.AbstractKernel, el::Inti.ReferenceInterpolant, û, x̂)\n\nGiven a kernel K, a reference element el, a function û defined on the reference element, and a point x̂ on the reference element, returns a function F that computes the complete kernel in polar coordinates centered at x̂ : F(ρ, θ) = K(x, y) * J(ŷ) * ρ * û(ŷ) where x = el(x̂), ŷ = x̂ + ρ * (cos(θ), sin(θ)), y = el(ŷ), and J(ŷ) is the integration measure at ŷ. F will be called as F(ρ, θ). K has to be called as K(qx, qy) where qx = (coords = x, normal = nx) and qy = (coords = y, normal = ny) are cartesian points with their normals. \n\nK must return a unique value.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#GuiggianiRichardsonDuffy.rho_fun-Tuple{Any, Any}","page":"Docstrings","title":"GuiggianiRichardsonDuffy.rho_fun","text":"rho_fun(ref_domain::Inti.ReferenceDomain, x̂)\n\nGiven a reference domain ref_domain and a point x̂ in the reference domain, returns the function ρ(θ) that gives the distance from x̂ to the boundary of the reference domain in the direction θ. ρ will be called as ρ(θ).\n\n\n\n\n\n","category":"method"}]
}
